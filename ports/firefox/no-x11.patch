--- gfx/angle/checkout/include/EGL/eglplatform.h
+++ gfx/angle/checkout/include/EGL/eglplatform.h
@@ -122,7 +122,8 @@ typedef intptr_t EGLNativeDisplayType;
 typedef intptr_t EGLNativePixmapType;
 typedef intptr_t EGLNativeWindowType;
 
-#elif defined(__unix__) || defined(USE_X11)
+#elif defined(__unix__)
+#if defined(USE_X11)
 
 /* X11 (tentative)  */
 #include <X11/Xlib.h>
@@ -131,6 +132,11 @@ typedef intptr_t EGLNativeWindowType;
 typedef Display *EGLNativeDisplayType;
 typedef Pixmap   EGLNativePixmapType;
 typedef Window   EGLNativeWindowType;
+#else
+typedef void              *EGLNativeDisplayType;
+typedef khronos_uintptr_t  EGLNativePixmapType;
+typedef khronos_uintptr_t  EGLNativeWindowType;
+#endif
 
 #elif defined(__APPLE__)
 
--- gfx/gl/GLContextProvider.h
+++ gfx/gl/GLContextProvider.h
@@ -55,17 +55,17 @@ namespace gl {
 #  define GL_CONTEXT_PROVIDER_NAME GLContextProviderX11
 #  include "GLContextProviderImpl.h"
 #  undef GL_CONTEXT_PROVIDER_NAME
-#  if defined(MOZ_WAYLAND)
-#    define GL_CONTEXT_PROVIDER_NAME GLContextProviderWayland
-#    include "GLContextProviderImpl.h"
-#    undef GL_CONTEXT_PROVIDER_NAME
-#    define GL_CONTEXT_PROVIDER_DEFAULT GLContextProviderWayland
-#  endif
 #  ifndef GL_CONTEXT_PROVIDER_DEFAULT
 #    define GL_CONTEXT_PROVIDER_DEFAULT GLContextProviderX11
 #  endif
 #endif
 
+#if defined(MOZ_WAYLAND)
+#  define GL_CONTEXT_PROVIDER_NAME GLContextProviderWayland
+#  include "GLContextProviderImpl.h"
+#  undef GL_CONTEXT_PROVIDER_NAME
+#  define GL_CONTEXT_PROVIDER_DEFAULT GLContextProviderWayland
+#endif
 #ifndef GL_CONTEXT_PROVIDER_DEFAULT
 #  define GL_CONTEXT_PROVIDER_DEFAULT GLContextProviderEGL
 #endif
--- gfx/gl/moz.build
+++ gfx/gl/moz.build
@@ -13,7 +13,7 @@ elif CONFIG["MOZ_WIDGET_TOOLKIT"] == "cocoa":
 elif CONFIG["MOZ_WIDGET_TOOLKIT"] == "uikit":
     gl_provider = "EAGL"
 elif CONFIG["MOZ_WIDGET_TOOLKIT"] == "gtk":
-    if CONFIG["MOZ_EGL_XRENDER_COMPOSITE"]:
+    if CONFIG["MOZ_EGL_XRENDER_COMPOSITE"] or CONFIG["MOZ_WAYLAND"]:
         gl_provider = "EGL"
     else:
         gl_provider = "GLX"
--- gfx/layers/AnimationHelper.h
+++ gfx/layers/AnimationHelper.h
@@ -7,6 +7,7 @@
 #ifndef mozilla_layers_AnimationHelper_h
 #define mozilla_layers_AnimationHelper_h
 
+#include "X11UndefineNone.h"
 #include "mozilla/dom/Nullable.h"
 #include "mozilla/ComputedTimingFunction.h"  // for ComputedTimingFunction
 #include "mozilla/layers/AnimationStorageData.h"
@@ -15,7 +16,6 @@
 #include "mozilla/TimeStamp.h"                 // for TimeStamp
 #include "mozilla/TimingParams.h"
 #include "mozilla/Types.h"  // for SideBits
-#include "X11UndefineNone.h"
 #include <unordered_map>
 
 namespace mozilla {
--- gfx/thebes/gfxPlatformGtk.cpp
+++ gfx/thebes/gfxPlatformGtk.cpp
@@ -30,7 +30,9 @@
 #include "mozilla/FontPropertyTypes.h"
 #include "mozilla/gfx/2D.h"
 #include "mozilla/gfx/Logging.h"
+#ifdef MOZ_X11
 #include "mozilla/gfx/XlibDisplay.h"
+#endif
 #include "mozilla/Monitor.h"
 #include "mozilla/Preferences.h"
 #include "mozilla/StaticPrefs_gfx.h"
@@ -62,6 +64,9 @@
 #  include "mozilla/widget/nsWaylandDisplay.h"
 #  include "mozilla/widget/DMABufLibWrapper.h"
 #  include "mozilla/StaticPrefs_widget.h"
+#  ifdef MOZ_WIDGET_GTK
+#  include "mozilla/WidgetUtilsGtk.h"
+#  endif
 #endif
 
 #define GDK_PIXMAP_SIZE_MAX 32767
@@ -128,7 +137,7 @@ gfxPlatformGtk::gfxPlatformGtk() {
 
   // Bug 1714483: Force disable FXAA Antialiasing on NV drivers. This is a
   // temporary workaround for a driver bug.
-  PR_SetEnv("__GL_ALLOW_FXAA_USAGE=0");
+  // PR_SetEnv("__GL_ALLOW_FXAA_USAGE=0");
 }
 
 gfxPlatformGtk::~gfxPlatformGtk() {
--- gfx/thebes/moz.build
+++ gfx/thebes/moz.build
@@ -116,7 +116,6 @@ elif CONFIG["MOZ_WIDGET_TOOLKIT"] == "gtk":
     ]
     EXPORTS.mozilla.gfx += [
         "PrintTargetPDF.h",
-        "PrintTargetPS.h",
     ]
     SOURCES += [
         "gfxFcPlatformFontList.cpp",
@@ -124,12 +123,12 @@ elif CONFIG["MOZ_WIDGET_TOOLKIT"] == "gtk":
         "gfxFT2Utils.cpp",
         "gfxPlatformGtk.cpp",
         "PrintTargetPDF.cpp",
-        "PrintTargetPS.cpp",
     ]
 
     if CONFIG["MOZ_X11"]:
         EXPORTS += [
             "gfxXlibSurface.h",
+            "PrintTargetPS.h",
         ]
         EXPORTS.mozilla.gfx += [
             "XlibDisplay.h",
@@ -137,6 +136,7 @@ elif CONFIG["MOZ_WIDGET_TOOLKIT"] == "gtk":
         SOURCES += [
             "gfxXlibSurface.cpp",
             "XlibDisplay.cpp",
+            "PrintTargetPS.cpp",
         ]
 
 elif CONFIG["MOZ_WIDGET_TOOLKIT"] == "windows":
--- gfx/webrender_bindings/RenderCompositorOGLSWGL.cpp
+++ gfx/webrender_bindings/RenderCompositorOGLSWGL.cpp
@@ -27,7 +27,9 @@
 #ifdef MOZ_WIDGET_GTK
 #  include "mozilla/widget/GtkCompositorWidget.h"
 #  include <gdk/gdk.h>
+#  ifdef MOZ_X11
 #  include <gdk/gdkx.h>
+#  endif
 #endif
 
 namespace mozilla {
--- toolkit/xre/nsAppRunner.cpp
+++ toolkit/xre/nsAppRunner.cpp
@@ -321,6 +321,7 @@ nsString gProcessStartupShortcut;
 #  endif
 #  ifdef MOZ_X11
 #    include <gdk/gdkx.h>
+#    undef None
 #  endif /* MOZ_X11 */
 #  include <fontconfig/fontconfig.h>
 #endif
@@ -345,7 +346,6 @@ void XRE_LibFuzzerSetDriver(LibFuzzerDriver aDriver) {
 #endif  // FUZZING
 
 // Undo X11/X.h's definition of None
-#undef None
 
 namespace mozilla {
 int (*RunGTest)(int*, char**) = 0;
--- widget/gtk/MozContainer.cpp
+++ widget/gtk/MozContainer.cpp
@@ -9,7 +9,9 @@
 
 #include <glib.h>
 #include <gtk/gtk.h>
+#ifdef MOZ_X11
 #include <gdk/gdkx.h>
+#endif
 #include <stdio.h>
 #include "mozilla/WidgetUtilsGtk.h"
 
--- widget/gtk/mozgtk/mozgtk.c
+++ widget/gtk/mozgtk/mozgtk.c
@@ -6,6 +6,7 @@
 
 #include "mozilla/Types.h"
 
+#if defined(MOZ_X11)
 #include <X11/Xlib.h>
 // Bug 1271100
 // We need to trick system Cairo into not using the XShm extension due to
@@ -19,3 +20,4 @@
 // ever can remove this workaround for system Cairo, we'll need something
 // to replace it for that purpose.
 MOZ_EXPORT Bool XShmQueryExtension(Display* aDisplay) { return False; }
+#endif
diff --git a/widget/gtk/nsClipboard.cpp b/widget/gtk/nsClipboard.cpp
index 75ad319a1e..f27e1d6659 100644
--- widget/gtk/nsClipboard.cpp
+++ widget/gtk/nsClipboard.cpp
@@ -9,7 +9,9 @@
 
 #include "nsArrayUtils.h"
 #include "nsClipboard.h"
+#if defined(MOZ_X11)
 #include "nsClipboardX11.h"
+#endif
 #if defined(MOZ_WAYLAND)
 #  include "nsClipboardWayland.h"
 #  include "nsClipboardWaylandAsync.h"
@@ -33,7 +35,9 @@
 #include "imgIContainer.h"
 
 #include <gtk/gtk.h>
+#ifdef MOZ_X11
 #include <gtk/gtkx.h>
+#endif
 
 #include "mozilla/Encoding.h"
 
@@ -102,16 +106,12 @@ nsClipboard::~nsClipboard() {
 NS_IMPL_ISUPPORTS(nsClipboard, nsIClipboard, nsIObserver)
 
 nsresult nsClipboard::Init(void) {
-  if (widget::GdkIsX11Display()) {
-    mContext = new nsRetrievalContextX11();
-#if defined(MOZ_WAYLAND)
-  } else if (widget::GdkIsWaylandDisplay()) {
+  if (widget::GdkIsWaylandDisplay()) {
     if (StaticPrefs::widget_wayland_async_clipboard_enabled_AtStartup()) {
       mContext = new nsRetrievalContextWaylandAsync();
     } else {
       mContext = new nsRetrievalContextWayland();
     }
-#endif
   } else {
     NS_WARNING("Missing nsRetrievalContext for nsClipboard!");
     return NS_OK;
--- widget/gtk/nsDeviceContextSpecG.cpp
+++ widget/gtk/nsDeviceContextSpecG.cpp
@@ -6,7 +6,9 @@
 #include "nsDeviceContextSpecG.h"
 
 #include "mozilla/gfx/PrintTargetPDF.h"
+#ifdef MOZ_X11
 #include "mozilla/gfx/PrintTargetPS.h"
+#endif
 #include "mozilla/Logging.h"
 #include "mozilla/Services.h"
 
@@ -46,7 +48,9 @@ using namespace mozilla;
 using mozilla::gfx::IntSize;
 using mozilla::gfx::PrintTarget;
 using mozilla::gfx::PrintTargetPDF;
+#ifdef MOZ_X11
 using mozilla::gfx::PrintTargetPS;
+#endif
 
 nsDeviceContextSpecGTK::nsDeviceContextSpecGTK()
     : mGtkPrintSettings(nullptr), mGtkPageSetup(nullptr) {}
@@ -119,12 +123,15 @@ already_AddRefed<PrintTarget> nsDeviceContextSpecGTK::MakePrintTarget() {
     return PrintTargetPDF::CreateOrNull(stream, size);
   }
 
+#ifdef MOZ_X11
   int32_t orientation = mPrintSettings->GetSheetOrientation();
   return PrintTargetPS::CreateOrNull(
       stream, size,
       orientation == nsIPrintSettings::kPortraitOrientation
           ? PrintTargetPS::PORTRAIT
           : PrintTargetPS::LANDSCAPE);
+#endif
+  return nullptr;
 }
 
 #define DECLARE_KNOWN_MONOCHROME_SETTING(key_, value_) {"cups-" key_, value_},
--- widget/gtk/nsDragService.cpp
+++ widget/gtk/nsDragService.cpp
@@ -23,7 +23,11 @@
 #include "prthread.h"
 #include <dlfcn.h>
 #include <gtk/gtk.h>
+#ifdef MOZ_X11
 #include <gdk/gdkx.h>
+#else
+#include <gdk/gdkwayland.h>
+#endif
 #include "nsCRT.h"
 #include "mozilla/BasicEvents.h"
 #include "mozilla/Services.h"
@@ -33,7 +37,6 @@
 #include "mozilla/WidgetUtilsGtk.h"
 #include "GRefPtr.h"
 
-#include "gfxXlibSurface.h"
 #include "gfxContext.h"
 #include "nsImageToPixbuf.h"
 #include "nsPresContext.h"
@@ -50,6 +53,8 @@
 #ifdef MOZ_WAYLAND
 #  include "nsClipboardWayland.h"
 #  include "gfxPlatformGtk.h"
+#else
+#include "gfxXlibSurface.h"
 #endif
 
 using namespace mozilla;
--- widget/gtk/nsGtkKeyUtils.cpp
+++ widget/gtk/nsGtkKeyUtils.cpp
@@ -12,10 +12,12 @@
 #include <gdk/gdkkeysyms.h>
 #include <algorithm>
 #include <gdk/gdk.h>
-#include <gdk/gdkx.h>
 #include <dlfcn.h>
 #include <gdk/gdkkeysyms-compat.h>
+#ifdef MOZ_X11
+#include <gdk/gdkx.h>
 #include <X11/XKBlib.h>
+#endif
 #include "X11UndefineNone.h"
 #include "IMContextWrapper.h"
 #include "WidgetUtils.h"
@@ -51,7 +53,7 @@ LazyLogModule gKeymapWrapperLog("KeymapWrapperWidgets");
 
 KeymapWrapper* KeymapWrapper::sInstance = nullptr;
 guint KeymapWrapper::sLastRepeatableHardwareKeyCode = 0;
-Time KeymapWrapper::sLastRepeatableKeyTime = 0;
+GTime KeymapWrapper::sLastRepeatableKeyTime = 0;
 KeymapWrapper::RepeatState KeymapWrapper::sRepeatState =
     KeymapWrapper::NOT_PRESSED;
 
@@ -346,9 +348,11 @@ KeymapWrapper::KeymapWrapper()
 
   g_object_ref(mGdkKeymap);
 
+#ifdef MOZ_X11
   if (GdkIsX11Display()) {
     InitXKBExtension();
   }
+#endif
 
   Init();
 }
@@ -365,16 +369,18 @@ void KeymapWrapper::Init() {
   mModifierKeys.Clear();
   memset(mModifierMasks, 0, sizeof(mModifierMasks));
 
+#ifdef MOZ_X11
   if (GdkIsX11Display()) {
     InitBySystemSettingsX11();
-  }
+  } else {
+#endif
 #ifdef MOZ_WAYLAND
-  else {
     InitBySystemSettingsWayland();
-  }
 #endif
-
+#ifdef MOZ_X11
+  }
   gdk_window_add_filter(nullptr, FilterEvents, this);
+#endif
 
   MOZ_LOG(gKeymapWrapperLog, LogLevel::Info,
           ("%p Init, CapsLock=0x%X, NumLock=0x%X, "
@@ -387,6 +393,7 @@ void KeymapWrapper::Init() {
            GetModifierMask(SUPER), GetModifierMask(HYPER)));
 }
 
+#ifdef MOZ_X11
 void KeymapWrapper::InitXKBExtension() {
   PodZero(&mKeyboardState);
 
@@ -619,6 +626,7 @@ void KeymapWrapper::InitBySystemSettingsX11() {
   XFreeModifiermap(xmodmap);
   XFree(xkeymap);
 }
+#endif
 
 #ifdef MOZ_WAYLAND
 void KeymapWrapper::SetModifierMask(xkb_keymap* aKeymap,
@@ -776,7 +784,9 @@ void KeymapWrapper::InitBySystemSettingsWayland() {
 #endif
 
 KeymapWrapper::~KeymapWrapper() {
+#ifdef MOZ_X11
   gdk_window_remove_filter(nullptr, FilterEvents, this);
+#endif
   if (mOnKeysChangedSignalHandle) {
     g_signal_handler_disconnect(mGdkKeymap, mOnKeysChangedSignalHandle);
   }
@@ -787,6 +797,7 @@ KeymapWrapper::~KeymapWrapper() {
   MOZ_LOG(gKeymapWrapperLog, LogLevel::Info, ("%p Destructor", this));
 }
 
+#ifdef MOZ_X11
 /* static */
 GdkFilterReturn KeymapWrapper::FilterEvents(GdkXEvent* aXEvent,
                                             GdkEvent* aGdkEvent,
@@ -900,6 +911,7 @@ GdkFilterReturn KeymapWrapper::FilterEvents(GdkXEvent* aXEvent,
 
   return GDK_FILTER_CONTINUE;
 }
+#endif
 
 static void ResetBidiKeyboard() {
   // Reset the bidi keyboard settings for the new GdkKeymap
@@ -1760,6 +1772,7 @@ void KeymapWrapper::InitKeyEvent(WidgetKeyboardEvent& aKeyEvent,
   // state.  It means if there're some pending modifier key press or
   // key release events, the result isn't what we want.
   guint modifierState = aGdkKeyEvent->state;
+#ifdef MOZ_X11
   GdkDisplay* gdkDisplay = gdk_display_get_default();
   if (aGdkKeyEvent->is_modifier && GdkIsX11Display(gdkDisplay)) {
     Display* display = gdk_x11_display_get_xdisplay(gdkDisplay);
@@ -1777,6 +1790,7 @@ void KeymapWrapper::InitKeyEvent(WidgetKeyboardEvent& aKeyEvent,
       }
     }
   }
+#endif
   InitInputEvent(aKeyEvent, modifierState);
 
   switch (aGdkKeyEvent->keyval) {
@@ -2023,6 +2037,7 @@ bool KeymapWrapper::IsLatinGroup(guint8 aGroup) {
   return result;
 }
 
+#ifdef MOZ_X11
 bool KeymapWrapper::IsAutoRepeatableKey(guint aHardwareKeyCode) {
   uint8_t indexOfArray = aHardwareKeyCode / 8;
   MOZ_ASSERT(indexOfArray < ArrayLength(mKeyboardState.auto_repeats),
@@ -2030,6 +2045,7 @@ bool KeymapWrapper::IsAutoRepeatableKey(guint aHardwareKeyCode) {
   char bitMask = 1 << (aHardwareKeyCode % 8);
   return (mKeyboardState.auto_repeats[indexOfArray] & bitMask) != 0;
 }
+#endif
 
 /* static */
 bool KeymapWrapper::IsBasicLatinLetterOrNumeral(uint32_t aCharCode) {
diff --git a/widget/gtk/nsGtkKeyUtils.h b/widget/gtk/nsGtkKeyUtils.h
index 07d60c27a6..43df8095fd 100644
--- widget/gtk/nsGtkKeyUtils.h
+++ widget/gtk/nsGtkKeyUtils.h
@@ -13,7 +13,9 @@
 #include "nsTArray.h"
 
 #include <gdk/gdk.h>
+#ifdef MOZ_X11
 #include <X11/XKBlib.h>
+#endif
 #ifdef MOZ_WAYLAND
 #  include <gdk/gdkwayland.h>
 #  include <xkbcommon/xkbcommon.h>
@@ -315,7 +317,9 @@ class KeymapWrapper {
    * See a call of XkbSelectEventDetails() with XkbControlsNotify in
    * InitXKBExtension().
    */
+#ifdef MOZ_X11
   XKeyboardState mKeyboardState;
+#endif
 
   /**
    * Pointer of the singleton instance.
@@ -326,7 +330,7 @@ class KeymapWrapper {
    * Auto key repeat management.
    */
   static guint sLastRepeatableHardwareKeyCode;
-  static Time sLastRepeatableKeyTime;
+  static GTime sLastRepeatableKeyTime;
   enum RepeatState { NOT_PRESSED, FIRST_PRESS, REPEATING };
   static RepeatState sRepeatState;
 
diff --git a/widget/gtk/nsPrintDialogGTK.cpp b/widget/gtk/nsPrintDialogGTK.cpp
index 0050af3af3..c2c02e59ff 100644
--- widget/gtk/nsPrintDialogGTK.cpp
+++ widget/gtk/nsPrintDialogGTK.cpp
@@ -26,7 +26,11 @@
 #include "nsIObserverService.h"
 
 // for gdk_x11_window_get_xid
+#ifdef MOZ_X11
 #include <gdk/gdkx.h>
+#else
+#include <gdk/gdkwayland.h>
+#endif
 #include <sys/types.h>
 #include <sys/stat.h>
 #include <fcntl.h>
@@ -525,6 +529,7 @@ static void wayland_window_handle_exported(GdkWindow* window,
 static gboolean window_export_handle(GtkWindow* window,
                                      GtkWindowHandleExported callback,
                                      gpointer user_data) {
+#ifdef MOZ_X11
   if (GdkIsX11Display()) {
     GdkWindow* gdk_window = gtk_widget_get_window(GTK_WIDGET(window));
     char* handle_str;
@@ -535,8 +540,9 @@ static gboolean window_export_handle(GtkWindow* window,
     g_free(handle_str);
     return true;
   }
+#endif
 #ifdef MOZ_WAYLAND
-  else if (GdkIsWaylandDisplay()) {
+  if (GdkIsWaylandDisplay()) {
     GdkWindow* gdk_window = gtk_widget_get_window(GTK_WIDGET(window));
     WaylandWindowHandleExportedData* data;
 
--- widget/moz.build
+++ widget/moz.build
@@ -258,7 +258,7 @@ if CONFIG["MOZ_INSTRUMENT_EVENT_LOOP"]:
 
 EXPORTS.ipc = ["nsGUIEventIPC.h"]
 
-if CONFIG["MOZ_X11"]:
+if CONFIG["MOZ_X11"] or CONFIG["MOZ_WAYLAND"]:
     DIRS += ["x11"]
 
 if toolkit in ("cocoa", "windows"):
@@ -315,7 +315,7 @@
         "windows/PCompositorWidget.ipdl",
         "windows/PlatformWidgetTypes.ipdlh",
     ]
-elif CONFIG["MOZ_WIDGET_TOOLKIT"] == "gtk" and CONFIG["MOZ_X11"]:
+elif CONFIG["MOZ_WIDGET_TOOLKIT"] == "gtk":
     IPDL_SOURCES = [
         "gtk/PCompositorWidget.ipdl",
         "gtk/PlatformWidgetTypes.ipdlh",
--- toolkit/moz.configure
+++ toolkit/moz.configure
@@ -1168,40 +1168,6 @@
 set_define("MOZ_RAW", depends_if("--enable-raw")(lambda _: True))
 
 
-# X11
-# ==============================================================
-set_config("MOZ_X11", True, when=toolkit_gtk)
-set_define("MOZ_X11", True, when=toolkit_gtk)
-
-
-@depends(webrtc, when=toolkit_gtk)
-def x11_libs(webrtc):
-    libs = [
-        "x11",
-        "xcb",
-        "xcb-shm",
-        "x11-xcb",
-        "xext",
-        "xrandr >= 1.4.0",
-    ]
-    if webrtc:
-        # third_party/libwebrtc/webrtc/webrtc_gn/moz.build adds those
-        # manually, ensure they're available.
-        libs += [
-            "xcomposite",
-            "xcursor",
-            "xdamage",
-            "xfixes",
-            "xi",
-            "xtst",
-        ]
-    return libs
-
-
-pkg_check_modules("MOZ_X11", x11_libs, when=toolkit_gtk)
-pkg_check_modules("MOZ_X11_SM", ["ice", "sm"], cflags_only=True, when=toolkit_gtk)
-
-
 # ASan Reporter Addon
 # ==============================================================
 option(
--- widget/gtk/nsWindow.h.orig	2022-01-14 06:26:17.000000000 +0800
+++ widget/gtk/nsWindow.h	2022-01-17 00:34:18.611405386 +0800
@@ -95,7 +95,9 @@
 
 namespace mozilla {
 class TimeStamp;
+#ifdef MOZ_X11
 class CurrentX11TimeGetter;
+#endif
 
 }  // namespace mozilla
 
@@ -277,7 +279,9 @@
 
   WidgetEventTime GetWidgetEventTime(guint32 aEventTime);
   mozilla::TimeStamp GetEventTimeStamp(guint32 aEventTime);
+#ifdef MOZ_X11
   mozilla::CurrentX11TimeGetter* GetCurrentTimeGetter();
+#endif
 
   virtual void SetInputContext(const InputContext& aContext,
                                const InputContextAction& aAction) override;
@@ -824,7 +828,9 @@
    */
   RefPtr<mozilla::widget::IMContextWrapper> mIMContext;
 
+#ifdef MOZ_X11
   mozilla::UniquePtr<mozilla::CurrentX11TimeGetter> mCurrentTimeGetter;
+#endif
   static GtkWindowDecoration sGtkWindowDecoration;
 
   static bool sTransparentMainWindow;
--- toolkit/components/remote/moz.build	2022-01-14 06:26:17.000000000 +0800
+++ toolkit/components/remote/moz.build	2022-01-14 06:26:17.000000000 +0800
@@ -26,7 +26,7 @@
             "nsUnixRemoteServer.h",
             "RemoteUtils.h",
         ]
-    else:
+    elif CONFIG["MOZ_X11"]:
         SOURCES += [
             "nsGTKRemoteServer.cpp",
             "nsXRemoteClient.cpp",
--- toolkit/components/remote/nsRemoteService.cpp	2022-01-14 03:26:16.000000000 +0800
+++ toolkit/components/remote/nsRemoteService.cpp	2022-01-14 03:26:16.000000000 +0800
@@ -12,11 +12,11 @@
 
 #ifdef MOZ_WIDGET_GTK
 #  include "mozilla/WidgetUtilsGtk.h"
-#  include "nsGTKRemoteServer.h"
 #  ifdef MOZ_ENABLE_DBUS
 #    include "nsDBusRemoteServer.h"
 #    include "nsDBusRemoteClient.h"
-#  else
+#  else if defined(MOZ_X11)
+#    include "nsGTKRemoteServer.h"
 #    include "nsXRemoteClient.h"
 #  endif
 #elif defined(XP_WIN)
@@ -102,7 +102,7 @@
 #ifdef MOZ_WIDGET_GTK
 #  if defined(MOZ_ENABLE_DBUS)
   client = MakeUnique<nsDBusRemoteClient>();
-#  else
+#  else if defined(MOZ_X11)
   client = MakeUnique<nsXRemoteClient>();
 #  endif
 #elif defined(XP_WIN)
@@ -146,7 +146,7 @@
 #ifdef MOZ_WIDGET_GTK
 #  if defined(MOZ_ENABLE_DBUS)
   mRemoteServer = MakeUnique<nsDBusRemoteServer>();
-#  else
+#  else if defined(MOZ_X11)
   mRemoteServer = MakeUnique<nsGTKRemoteServer>();
 #  endif
 #elif defined(XP_WIN)
--- widget/gtk/GtkCompositorWidget.cpp	2022-01-14 03:26:17.000000000 +0800
+++ widget/gtk/GtkCompositorWidget.cpp	2022-01-17 23:44:19.674746980 +0800
@@ -49,9 +49,15 @@
   auto size = mClientSize.Lock();
   *size = aInitData.InitialClientSize();
 
+#if defined(MOZ_X11)
   LOG("GtkCompositorWidget::GtkCompositorWidget() [%p] mXWindow %p "
       "mIsRenderingSuspended %d\n",
       (void*)mWidget.get(), (void*)mXWindow, !!mIsRenderingSuspended);
+#else
+  LOG("GtkCompositorWidget::GtkCompositorWidget() [%p] mXWindow %p "
+      "mIsRenderingSuspended %d\n",
+      (void*)mWidget.get(), NULL, !!mIsRenderingSuspended);
+#endif
 }
 
 GtkCompositorWidget::~GtkCompositorWidget() {
--- gfx/gl/GLContextProviderWayland.cpp
+++ gfx/gl/GLContextProviderWayland.cpp
@@ -14,7 +14,7 @@
 using namespace mozilla::gfx;
 using namespace mozilla::widget;
 
-static class GLContextProviderX11 sGLContextProviderX11;
+static class GLContextProviderEGL sGLContextProviderX11;
 static class GLContextProviderEGL sGLContextProviderEGL;
 
 // Note that if there is no GTK display, `GdkIsX11Display` and
--- toolkit/xre/nsGDKErrorHandler.cpp
+++ toolkit/xre/nsGDKErrorHandler.cpp
@@ -6,14 +6,19 @@
 #include "nsGDKErrorHandler.h"
 
 #include <gtk/gtk.h>
-#include <gdk/gdkx.h>
+#ifdef MOZ_WAYLAND
+#include <gdk/gdkwayland.h>
+#endif
 #include <errno.h>
 #include <stdlib.h>
 #include <string.h>
 
 #include "nsDebug.h"
 #include "nsString.h"
+#ifdef MOZ_X11
+#include <gdk/gdkx.h>
 #include "nsX11ErrorHandler.h"
+#endif
 
 #include "prenv.h"
 
@@ -27,6 +32,7 @@
 static void GdkErrorHandler(const gchar* log_domain, GLogLevelFlags log_level,
                             const gchar* message, gpointer user_data) {
   if (strstr(message, "X Window System error")) {
+#ifdef MOZ_X11
     XErrorEvent event;
     nsDependentCString buffer(message);
     char* endptr;
@@ -92,6 +98,7 @@
     event.resourceid = 0;
 
     X11Error(event.display, &event);
+#endif
   } else {
     g_log_default_handler(log_domain, log_level, message, user_data);
     MOZ_CRASH_UNSAFE(message);
@@ -103,7 +110,9 @@
                     (GLogLevelFlags)(G_LOG_LEVEL_ERROR | G_LOG_FLAG_FATAL |
                                      G_LOG_FLAG_RECURSION),
                     GdkErrorHandler, nullptr);
+#ifdef MOZ_X11
   if (PR_GetEnv("MOZ_X_SYNC")) {
     XSynchronize(GDK_DISPLAY_XDISPLAY(gdk_display_get_default()), X11True);
   }
+#endif
 }
--- gfx/cairo/cairo/src/moz.build	2022-01-14 06:26:16.000000000 +0800
+++ gfx/cairo/cairo/src/moz.build	2022-01-14 06:26:16.000000000 +0800
@@ -72,7 +72,7 @@
     SOURCES += [
         'cairo-beos-surface.cpp',
     ]
-elif CONFIG['MOZ_WIDGET_TOOLKIT'] == 'gtk':
+elif CONFIG['MOZ_WIDGET_TOOLKIT'] == 'gtk' and CONFIG['MOZ_X11']:
     EXPORTS.cairo += [
         'cairo-ps.h',
     ]
--- widget/gtk/WindowSurfaceProvider.cpp	2022-01-14 06:26:17.000000000 +0800
+++ widget/gtk/WindowSurfaceProvider.cpp	2022-01-18 14:48:29.193204284 +0800
@@ -12,6 +12,7 @@
 #include "nsWindow.h"
 
 #ifdef MOZ_WAYLAND
+#  include "mozilla/WidgetUtilsGtk.h"
 #  include "mozilla/StaticPrefs_widget.h"
 #  include "WindowSurfaceWaylandMultiBuffer.h"
 #endif
--- widget/gtk/nsWidgetFactory.cpp	2022-01-14 03:26:17.000000000 +0800
+++ widget/gtk/nsWidgetFactory.cpp	2022-01-14 03:26:17.000000000 +0800
@@ -36,7 +36,6 @@
 using namespace mozilla;
 using namespace mozilla::widget;
 
-#ifdef MOZ_X11
 NS_IMPL_COMPONENT_FACTORY(nsIClipboard) {
   nsCOMPtr<nsIClipboard> inst;
   if (gfxPlatform::IsHeadless()) {
@@ -51,7 +50,6 @@
 
   return inst.forget().downcast<nsISupports>();
 }
-#endif
 
 nsresult nsWidgetGtk2ModuleCtor() { return nsAppShellInit(); }
 
--- toolkit/xre/moz.build	2022-01-23 14:14:30.545217387 +0800
+++ toolkit/xre/moz.build	2022-01-23 14:14:30.545217387 +0800
@@ -156,7 +156,7 @@
     "ProfileReset.cpp",
 ]
 
-if CONFIG["MOZ_X11"]:
+if CONFIG["MOZ_X11"] or CONFIG["MOZ_WAYLAND"]:
     UNIFIED_SOURCES += [
         "glxtest.cpp",
     ]
@@ -187,7 +187,7 @@
 
 FINAL_LIBRARY = "xul"
 
-if CONFIG["MOZ_X11"]:
+if CONFIG["MOZ_X11"] or CONFIG["MOZ_WAYLAND"]:
     DEFINES["USE_GLX_TEST"] = True
 
 for var in (
--- widget/InProcessCompositorWidget.cpp	2022-01-24 15:35:11.376001012 +0800
+++ widget/InProcessCompositorWidget.cpp	2022-01-24 15:35:11.376001012 +0800
@@ -12,7 +12,7 @@
 
 // Platforms with no OOP compositor process support use
 // InProcessCompositorWidget by default.
-#if !defined(MOZ_WIDGET_SUPPORTS_OOP_COMPOSITING)
+#if !defined(MOZ_WIDGET_SUPPORTS_OOP_COMPOSITING) && !defined(MOZ_WAYLAND)
 /* static */
 RefPtr<CompositorWidget> CompositorWidget::CreateLocal(
     const CompositorWidgetInitData& aInitData,
--- widget/gtk/mozwayland/moz.build	2022-01-25 00:34:01.993828266 +0800
+++ widget/gtk/mozwayland/moz.build	2022-01-25 00:34:01.993828266 +0800
@@ -4,9 +4,6 @@
 # License, v. 2.0. If a copy of the MPL was not distributed with this
 # file, You can obtain one at http://mozilla.org/MPL/2.0/.
 
-SOURCES += [
-    "mozwayland.c",
-]
 EXPORTS.mozilla.widget += [
     "mozwayland.h",
 ]
--- widget/gtk/nsWindow.cpp.orig	2022-01-14 06:26:17.000000000 +0800
+++ widget/gtk/nsWindow.cpp	2022-01-17 00:43:00.541484804 +0800
@@ -58,7 +58,6 @@
 #include "mozilla/UniquePtrExtensions.h"
 #include "mozilla/WidgetUtils.h"
 #include "mozilla/WritingModes.h"
-#include "mozilla/X11Util.h"
 #include "mozilla/XREAppData.h"
 #include "NativeKeyBindings.h"
 #include "nsAppDirectoryServiceDefs.h"
@@ -90,7 +89,6 @@
 #include "ScreenHelperGTK.h"
 #include "SystemTimeConverter.h"
 #include "WidgetUtilsGtk.h"
-#include "mozilla/X11Util.h"
 
 #ifdef ACCESSIBILITY
 #  include "mozilla/a11y/LocalAccessible.h"
@@ -98,18 +96,22 @@
 #  include "nsAccessibilityService.h"
 #endif
 
+#include "GtkCompositorWidget.h"
 #ifdef MOZ_X11
+#  include "mozilla/X11Util.h"
 #  include <gdk/gdkkeysyms-compat.h>
 #  include <X11/Xatom.h>
 #  include <X11/extensions/XShm.h>
 #  include <X11/extensions/shape.h>
 #  include "gfxXlibSurface.h"
 #  include "GLContextGLX.h"  // for GLContextGLX::FindVisual()
-#  include "GLContextEGL.h"  // for GLContextEGL::FindVisual()
 #  include "WindowSurfaceX11Image.h"
 #  include "WindowSurfaceX11SHM.h"
 #endif
 #ifdef MOZ_WAYLAND
+#  include <gdk/gdk.h>
+#  include <gdk/gdkkeysyms-compat.h>
+#  include "GLContextEGL.h"
 #  include "nsIClipboard.h"
 #  include "nsView.h"
 #endif
@@ -119,7 +121,9 @@
 using namespace mozilla::layers;
 using namespace mozilla::widget;
 using mozilla::gl::GLContextEGL;
+#ifdef MOZ_X11
 using mozilla::gl::GLContextGLX;
+#endif
 
 // Don't put more than this many rects in the dirty region, just fluff
 // out to the bounding-box if there are more
@@ -276,6 +280,7 @@
 
 namespace mozilla {
 
+#ifdef MOZ_X11
 class CurrentX11TimeGetter {
  public:
   explicit CurrentX11TimeGetter(GdkWindow* aWindow)
@@ -323,6 +328,7 @@
   GdkWindow* mWindow;
   TimeStamp mAsyncUpdateStart;
 };
+#endif
 
 }  // namespace mozilla
 
@@ -2575,6 +2581,7 @@
     return false;
   }
 
+#ifdef MOZ_X11
   Display* xdisplay = gdk_x11_get_default_xdisplay();
   GdkScreen* screen = gdk_window_get_screen(gdk_window);
   Window root_win = GDK_WINDOW_XID(gdk_screen_get_root_window(screen));
@@ -2637,6 +2644,7 @@
   }
 
   wmName = reinterpret_cast<const char*>(prop_return);
+#endif
   return true;
 }
 
@@ -2695,6 +2703,7 @@
     return;
   }
 
+#ifdef MOZ_X11
   LOG("nsWindow::GetWorkspaceID()\n");
 
   // Get the gdk window for this widget.
@@ -2729,9 +2738,11 @@
   LOG("  got workspace ID %d", (int32_t)wm_desktop[0]);
   workspaceID.AppendInt((int32_t)wm_desktop[0]);
   g_free(wm_desktop);
+#endif
 }
 
 void nsWindow::MoveToWorkspace(const nsAString& workspaceIDStr) {
+#ifdef MOZ_X11
   nsresult rv = NS_OK;
   int32_t workspaceID = workspaceIDStr.ToInteger(&rv);
 
@@ -2776,6 +2787,7 @@
 
   XFlush(xdisplay);
   LOG("  moved to workspace");
+#endif
 }
 
 using SetUserTimeFunc = void (*)(GdkWindow*, guint32);
@@ -2816,9 +2828,13 @@
   // button and key releases.  Therefore use the most recent of
   // gdk_x11_display_get_user_time and the last time that we have seen.
   GdkDisplay* gdkDisplay = gdk_display_get_default();
+#ifdef MOZ_X11
   guint32 timestamp = GdkIsX11Display(gdkDisplay)
                           ? gdk_x11_display_get_user_time(gdkDisplay)
                           : gtk_get_current_event_time();
+#else
+  guint32 timestamp = gtk_get_current_event_time();
+#endif
 
   if (sLastUserInputTime != GDK_CURRENT_TIME &&
       TimestampIsNewerThan(sLastUserInputTime, timestamp)) {
@@ -3051,6 +3067,7 @@
     return;
   }
 
+#ifdef MOZ_X11
   GdkAtom cardinal_atom = gdk_x11_xatom_to_atom(XA_CARDINAL);
 
   GdkAtom type_returned;
@@ -3076,6 +3093,7 @@
 
     mClientOffset = nsIntPoint(left, top);
   }
+#endif
 
   // Send a WindowMoved notification. This ensures that BrowserParent
   // picks up the new client offset and sends it to the child process
@@ -3094,6 +3112,7 @@
 
 gboolean nsWindow::OnPropertyNotifyEvent(GtkWidget* aWidget,
                                          GdkEventProperty* aEvent) {
+#ifdef MOZ_X11
   if (aEvent->atom == gdk_atom_intern("_NET_FRAME_EXTENTS", FALSE)) {
     UpdateClientOffsetFromFrameExtents();
     return FALSE;
@@ -3105,6 +3124,7 @@
     return TRUE;
   }
   return FALSE;
+#endif
 }
 
 static GdkCursor* GetCursorForImage(const nsIWidget::Cursor& aCursor,
@@ -3241,9 +3261,11 @@
       return GetToplevelWidget();
 
     case NS_NATIVE_WINDOW_WEBRTC_DEVICE_ID:
+#ifdef MOZ_X11
       if (GdkIsX11Display()) {
         return (void*)GDK_WINDOW_XID(gdk_window_get_toplevel(mGdkWindow));
       }
+#endif
       NS_WARNING(
           "nsWindow::GetNativeData(): NS_NATIVE_WINDOW_WEBRTC_DEVICE_ID is not "
           "handled on Wayland!");
@@ -3264,11 +3286,13 @@
       return nullptr;
     case NS_NATIVE_EGL_WINDOW: {
       void* eglWindow = nullptr;
+#ifdef MOZ_X11
       if (GdkIsX11Display()) {
         eglWindow = mGdkWindow ? (void*)GDK_WINDOW_XID(mGdkWindow) : nullptr;
       }
+#endif
 #ifdef MOZ_WAYLAND
-      else {
+      {
         eglWindow = moz_container_wayland_get_egl_window(
             mContainer, FractionalScaleFactor());
       }
@@ -3523,8 +3547,13 @@
   nsIWidgetListener* listener = GetListener();
   if (!listener) return FALSE;
 
+#ifdef MOZ_X11
   LOG("received expose event %p 0x%lx (rects follow):\n", mGdkWindow,
       GdkIsX11Display() ? gdk_x11_window_get_xid(mGdkWindow) : 0);
+#else
+  LOG("received expose event [%p] %p 0x%lx (rects follow):\n", this,
+       mGdkWindow, 0);
+#endif
   LayoutDeviceIntRegion exposeRegion;
   if (!ExtractExposeRegion(exposeRegion, cr)) {
     return FALSE;
@@ -3847,7 +3876,6 @@
                         &allocation.height);
     OnSizeAllocate(&allocation);
   }
-
   return FALSE;
 }
 
@@ -4064,6 +4092,7 @@
     MOZ_ASSERT(gdk_window, "gdk_window_get_toplevel should not return null");
 
     bool canDrag = true;
+#ifdef MOZ_X11
     if (GdkIsX11Display()) {
       // Workaround for https://bugzilla.gnome.org/show_bug.cgi?id=789054
       // To avoid crashes disable double-click on WM without _NET_WM_MOVERESIZE.
@@ -4074,6 +4103,7 @@
         canDrag = false;
       }
     }
+#endif
 
     if (canDrag) {
       gdk_window_begin_move_drag(gdk_window, 1, aEvent->x_root, aEvent->y_root,
@@ -4524,16 +4554,20 @@
     int64_t tick =
         BaseTimeDurationPlatformUtils::TicksFromMilliseconds(timestampTime);
     eventTimeStamp = TimeStamp::FromSystemTime(tick);
-  } else {
+  }
+#ifdef MOZ_X11
+  else {
     CurrentX11TimeGetter* getCurrentTime = GetCurrentTimeGetter();
     MOZ_ASSERT(getCurrentTime,
                "Null current time getter despite having a window");
     eventTimeStamp =
         TimeConverter().GetTimeStampFromSystemTime(aEventTime, *getCurrentTime);
   }
+#endif
   return eventTimeStamp;
 }
 
+#ifdef MOZ_X11
 mozilla::CurrentX11TimeGetter* nsWindow::GetCurrentTimeGetter() {
   MOZ_ASSERT(mGdkWindow, "Expected mGdkWindow to be set");
   if (MOZ_UNLIKELY(!mCurrentTimeGetter)) {
@@ -4541,6 +4575,7 @@
   }
   return mCurrentTimeGetter.get();
 }
+#endif
 
 gboolean nsWindow::OnKeyPressEvent(GdkEventKey* aEvent) {
   LOG("OnKeyPressEvent");
@@ -5202,7 +5237,11 @@
   LOG("nsWindow::EnableRenderingToWindow()");
 
   if (mCompositorWidgetDelegate) {
+#ifdef MOZ_X11
     mCompositorWidgetDelegate->EnableRendering(mXWindow, mIsShaped);
+#else
+    mCompositorWidgetDelegate->EnableRendering(NULL, false);
+#endif
   }
 
   if (GdkIsWaylandDisplay()) {
@@ -5308,8 +5347,12 @@
     EnsureGrabs();
   }
 
+#ifdef MOZ_X11
   LOG("  finished, new GdkWindow %p XID 0x%lx\n", mGdkWindow,
       GdkIsX11Display() ? gdk_x11_window_get_xid(mGdkWindow) : 0);
+#else
+  LOG("  finished, new GdkWindow %p XID 0x%lx\n", mGdkWindow, 0);
+#endif
 }
 
 void nsWindow::ReleaseGdkWindow() {
@@ -5448,12 +5491,13 @@
       type = GTK_WINDOW_TOPLEVEL;
     }
   }
-  mShell = gtk_window_new(type);
 
   // Ensure gfxPlatform is initialized, since that is what initializes
   // gfxVars, used below.
   Unused << gfxPlatform::GetPlatform();
 
+  mShell = gtk_window_new(type);
+
   if (mWindowType == eWindowType_toplevel ||
       mWindowType == eWindowType_dialog) {
     mGtkWindowDecoration = GetSystemGtkWindowDecoration();
@@ -5848,10 +5892,16 @@
                    nullptr);
 
   LOG("nsWindow type %d %s\n", mWindowType, mIsPIPWindow ? "PIP window" : "");
+#ifdef MOZ_X11
   LOG("\tmShell %p mContainer %p mGdkWindow %p XID 0x%lx\n", mShell, mContainer,
       mGdkWindow,
       (GdkIsX11Display() && mGdkWindow) ? gdk_x11_window_get_xid(mGdkWindow)
                                         : 0);
+#else
+    LOG("\tmShell %p mContainer %p mGdkWindow %p XID 0x%lx\n", mShell,
+         mContainer, mGdkWindow,
+         0);
+#endif
 
   // Set default application name when it's empty.
   if (mGtkWindowAppName.IsEmpty()) {
@@ -5956,6 +6006,7 @@
     return;
   }
 
+#ifdef MOZ_X11
   // Set position to hidden window on X11 may fail, so save the position
   // and move it when it's shown.
   if (aMoved && GdkIsX11Display() && IsPopup() &&
@@ -5964,6 +6015,7 @@
     mHiddenPopupPositioned = true;
     mPopupPosition = topLeft;
   }
+#endif
 
   if (IsWaylandPopup()) {
     NativeMoveResizeWaylandPopup(aMoved, aResized);
@@ -6696,6 +6748,7 @@
     cairo_surface_destroy(surface);
   }
 
+#ifdef MOZ_X11
   if (!mNeedsShow) {
     Display* xDisplay = GDK_WINDOW_XDISPLAY(mGdkWindow);
     Window xDrawable = GDK_WINDOW_XID(mGdkWindow);
@@ -6716,6 +6769,7 @@
 
     XFreePixmap(xDisplay, maskPixmap);
   }
+#endif
 }
 
 void nsWindow::GrabPointer(guint32 aTime) {
@@ -6989,7 +7043,7 @@
   GdkScreen* screen = gtk_widget_get_screen(aShell);
   GdkAtom atom = gdk_atom_intern("_NET_WM_STATE_FULLSCREEN", FALSE);
   return gdk_x11_screen_supports_net_wm_hint(screen, atom);
-#elif
+#else
   return true;
 #endif
 }
@@ -8273,6 +8327,7 @@
     return false;
   }
 
+#ifdef MOZ_X11
   if (GdkIsX11Display()) {
     // Workaround for https://bugzilla.gnome.org/show_bug.cgi?id=789054
     // To avoid crashes disable double-click on WM without _NET_WM_MOVERESIZE.
@@ -8288,6 +8343,7 @@
       }
     }
   }
+#endif
 
   // FIXME: It would be nice to have the widget position at the time
   // of the event, but it's relatively unlikely that the widget has
@@ -9001,10 +9057,15 @@
     XFlush(display);
     displayName = nsCString(XDisplayString(display));
   }
-#endif
   *aInitData = mozilla::widget::GtkCompositorWidgetInitData(
       (mXWindow != X11None) ? mXWindow : (uintptr_t) nullptr, displayName,
       mIsShaped, GdkIsX11Display(), GetClientSize());
+#else
+  *aInitData = mozilla::widget::GtkCompositorWidgetInitData(
+      (uintptr_t) nullptr,
+      nsCString(), 0,
+      0, GetClientSize());
+#endif
 }
 
 #ifdef MOZ_X11
--- widget/gtk/components.conf.orig	2022-01-25 02:05:43.811930918 +0800
+++ widget/gtk/components.conf	2022-01-25 02:06:34.430234335 +0800
@@ -76,53 +76,49 @@
         'headers': ['/widget/gtk/nsApplicationChooser.h'],
         'processes': ProcessSelector.MAIN_PROCESS_ONLY,
     },
+    {
+        'js_name': 'clipboard',
+        'cid': '{8b5314ba-db01-11d2-96ce-0060b0fb9956}',
+        'contract_ids': ['@mozilla.org/widget/clipboard;1'],
+        'interfaces': ['nsIClipboard'],
+        'type': 'nsIClipboard',
+        'processes': ProcessSelector.MAIN_PROCESS_ONLY,
+        'overridable': True,
+    },
+    {
+        'cid': '{77221d5a-1dd2-11b2-8c69-c710f15d2ed5}',
+        'contract_ids': ['@mozilla.org/widget/clipboardhelper;1'],
+        'type': 'nsClipboardHelper',
+        'headers': ['/widget/nsClipboardHelper.h'],
+    },
+    {
+        'cid': '{8b5314bb-db01-11d2-96ce-0060b0fb9956}',
+        'contract_ids': ['@mozilla.org/widget/dragservice;1'],
+        'singleton': True,
+        'type': 'nsDragService',
+        'headers': ['/widget/gtk/nsDragService.h'],
+        'constructor': 'nsDragService::GetInstance',
+        'processes': ProcessSelector.MAIN_PROCESS_ONLY,
+    },
+    {
+        'name': 'GfxInfo',
+        'cid': '{d755a760-9f27-11df-0800-200c9a664242}',
+        'contract_ids': ['@mozilla.org/gfx/info;1'],
+        'type': 'mozilla::widget::GfxInfo',
+        'headers': ['/widget/gtk/GfxInfo.h'],
+        'init_method': 'Init',
+        'processes': ProcessSelector.ALLOW_IN_GPU_PROCESS,
+    },
+    {
+        'cid': '{6987230e-0098-4e78-bc5f-1493ee7519fa}',
+        'contract_ids': ['@mozilla.org/widget/useridleservice;1'],
+        'singleton': True,
+        'type': 'nsUserIdleService',
+        'headers': ['/widget/gtk/nsUserIdleServiceGTK.h'],
+        'constructor': 'nsUserIdleServiceGTK::GetInstance',
+    },
 ]
 
-if defined('MOZ_X11'):
-    Classes += [
-        {
-            'js_name': 'clipboard',
-            'cid': '{8b5314ba-db01-11d2-96ce-0060b0fb9956}',
-            'contract_ids': ['@mozilla.org/widget/clipboard;1'],
-            'interfaces': ['nsIClipboard'],
-            'type': 'nsIClipboard',
-            'processes': ProcessSelector.MAIN_PROCESS_ONLY,
-            'overridable': True,
-        },
-        {
-            'cid': '{77221d5a-1dd2-11b2-8c69-c710f15d2ed5}',
-            'contract_ids': ['@mozilla.org/widget/clipboardhelper;1'],
-            'type': 'nsClipboardHelper',
-            'headers': ['/widget/nsClipboardHelper.h'],
-        },
-        {
-            'cid': '{8b5314bb-db01-11d2-96ce-0060b0fb9956}',
-            'contract_ids': ['@mozilla.org/widget/dragservice;1'],
-            'singleton': True,
-            'type': 'nsDragService',
-            'headers': ['/widget/gtk/nsDragService.h'],
-            'constructor': 'nsDragService::GetInstance',
-            'processes': ProcessSelector.MAIN_PROCESS_ONLY,
-        },
-        {
-            'name': 'GfxInfo',
-            'cid': '{d755a760-9f27-11df-0800-200c9a664242}',
-            'contract_ids': ['@mozilla.org/gfx/info;1'],
-            'type': 'mozilla::widget::GfxInfo',
-            'headers': ['/widget/gtk/GfxInfo.h'],
-            'init_method': 'Init',
-            'processes': ProcessSelector.ALLOW_IN_GPU_PROCESS,
-        },
-        {
-            'cid': '{6987230e-0098-4e78-bc5f-1493ee7519fa}',
-            'contract_ids': ['@mozilla.org/widget/useridleservice;1'],
-            'singleton': True,
-            'type': 'nsUserIdleService',
-            'headers': ['/widget/gtk/nsUserIdleServiceGTK.h'],
-            'constructor': 'nsUserIdleServiceGTK::GetInstance',
-        },
-    ]
-
 if defined('NS_PRINTING'):
     Classes += [
         {
--- widget/gtk/nsUserIdleServiceGTK.h	2022-01-20 06:07:50.000000000 +0800
+++ widget/gtk/nsUserIdleServiceGTK.h	2022-01-20 06:07:50.000000000 +0800
@@ -9,6 +9,7 @@
 #define nsUserIdleServiceGTK_h__
 
 #include "nsUserIdleService.h"
+#ifdef MOZ_X11
 #include <X11/Xlib.h>
 #include <X11/Xutil.h>
 #include <gdk/gdkx.h>
@@ -21,6 +22,7 @@
   unsigned long idle;          // milliseconds idle
   unsigned long event_mask;    // event stuff
 } XScreenSaverInfo;
+#endif
 
 class nsUserIdleServiceGTK : public nsUserIdleService {
  public:
@@ -40,7 +42,9 @@
 
  private:
   ~nsUserIdleServiceGTK();
+#ifdef MOZ_X11
   XScreenSaverInfo* mXssInfo;
+#endif
 
  protected:
   nsUserIdleServiceGTK();
--- widget/gtk/moz.build.orig	2022-01-25 11:04:49.650420160 +0800
+++ widget/gtk/moz.build	2022-01-25 11:05:04.417401668 +0800
@@ -22,6 +22,7 @@
 DIRS += ["mozgtk"]
 
 if CONFIG["MOZ_WAYLAND"]:
+    OS_LIBS += ["wayland-client", "wayland-egl"]
     DIRS += ["wayland", "mozwayland"]
 
 EXPORTS += [
@@ -33,6 +34,7 @@
 EXPORTS.mozilla += ["WidgetUtilsGtk.h"]
 
 EXPORTS.mozilla.widget += [
+    "GtkCompositorWidget.h",
     "WindowSurface.h",
     "WindowSurfaceProvider.h",
 ]
@@ -81,18 +83,25 @@
 
 if CONFIG["MOZ_WAYLAND"]:
     UNIFIED_SOURCES += [
+        "CompositorWidgetChild.cpp",
+        "CompositorWidgetParent.cpp",
         "DMABufLibWrapper.cpp",
         "DMABufSurface.cpp",
+        "InProcessGtkCompositorWidget.cpp",
         "MozContainerWayland.cpp",
         "nsClipboardWayland.cpp",
         "nsClipboardWaylandAsync.cpp",
+        "nsUserIdleServiceGTK.cpp",
         "nsWaylandDisplay.cpp",
         "WaylandBuffer.cpp",
         "WindowSurfaceWaylandMultiBuffer.cpp",
     ]
     EXPORTS.mozilla.widget += [
+        "CompositorWidgetChild.h",
+        "CompositorWidgetParent.h",
         "DMABufLibWrapper.h",
         "DMABufSurface.h",
+        "InProcessGtkCompositorWidget.h",
         "MozContainerWayland.h",
         "nsWaylandDisplay.h",
         "WaylandBuffer.h",
@@ -113,7 +122,6 @@
     EXPORTS.mozilla.widget += [
         "CompositorWidgetChild.h",
         "CompositorWidgetParent.h",
-        "GtkCompositorWidget.h",
         "InProcessGtkCompositorWidget.h",
     ]
 
@@ -144,7 +152,7 @@
     "/widget/headless",
 ]
 
-if CONFIG["MOZ_X11"]:
+if CONFIG["MOZ_X11"] or CONFIG["MOZ_WAYLAND"]:
     LOCAL_INCLUDES += [
         "/widget/x11",
     ]
--- widget/gtk/nsUserIdleServiceGTK.cpp.orig	2022-01-25 11:04:49.697087816 +0800
+++ widget/gtk/nsUserIdleServiceGTK.cpp	2022-01-25 11:09:44.370573483 +0800
@@ -17,6 +17,7 @@
 
 static mozilla::LazyLogModule sIdleLog("nsIUserIdleService");
 
+#ifdef MOZ_X11
 typedef bool (*_XScreenSaverQueryExtension_fn)(Display* dpy, int* event_base,
                                                int* error_base);
 
@@ -25,16 +26,18 @@
 typedef void (*_XScreenSaverQueryInfo_fn)(Display* dpy, Drawable drw,
                                           XScreenSaverInfo* info);
 
-static bool sInitialized = false;
 static _XScreenSaverQueryExtension_fn _XSSQueryExtension = nullptr;
 static _XScreenSaverAllocInfo_fn _XSSAllocInfo = nullptr;
 static _XScreenSaverQueryInfo_fn _XSSQueryInfo = nullptr;
+#endif
+static bool sInitialized = false;
 
 static void Initialize() {
   if (!mozilla::widget::GdkIsX11Display()) {
     return;
   }
 
+#ifdef MOZ_X11
   // This will leak - See comments in ~nsUserIdleServiceGTK().
   PRLibrary* xsslib = PR_LoadLibrary("libXss.so.1");
   if (!xsslib)  // ouch.
@@ -57,16 +60,23 @@
     MOZ_LOG(sIdleLog, LogLevel::Warning, ("Failed to get XSSAllocInfo!\n"));
   if (!_XSSQueryInfo)
     MOZ_LOG(sIdleLog, LogLevel::Warning, ("Failed to get XSSQueryInfo!\n"));
+#endif
 
   sInitialized = true;
 }
 
-nsUserIdleServiceGTK::nsUserIdleServiceGTK() : mXssInfo(nullptr) {
+nsUserIdleServiceGTK::nsUserIdleServiceGTK()
+#ifdef MOZ_X11
+    : mXssInfo(nullptr)
+#endif
+{
   Initialize();
 }
 
 nsUserIdleServiceGTK::~nsUserIdleServiceGTK() {
+#ifdef MOZ_X11
   if (mXssInfo) XFree(mXssInfo);
+#endif
 
 // It is not safe to unload libXScrnSaver until each display is closed because
 // the library registers callbacks through XESetCloseDisplay (Bug 397607).
@@ -85,6 +95,7 @@
     return false;
   }
 
+#ifdef MOZ_X11
   // Ask xscreensaver about idle time:
   *aIdleTime = 0;
 
@@ -107,6 +118,7 @@
     *aIdleTime = mXssInfo->idle;
     return true;
   }
+#endif
   // If we get here, we couldn't get to XScreenSaver:
   MOZ_LOG(sIdleLog, LogLevel::Warning, ("XSSQueryExtension returned false!\n"));
   return false;
